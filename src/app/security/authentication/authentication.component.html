<p>
  O provedor de autenticação AdonisJs é um sistema completo para 
  autenticar solicitações HTTP usando vários autenticadores.
</p>
<p>
  Usando autenticadores, você pode criar sistemas tradicionais de login baseados em sessão e proteger suas APIs.
</p>
<blockquote>
  Para opinar sobre o gerenciamento de perfis de usuários, confira o 
  pacote oficial do <a href="https://github.com/adonisjs/adonis-persona" target="_blank" rel="noopener noreferrer">Adonis Persona</a> 
  - um serviço simples e funcional 
  para permitir que você crie, verifique e atualize perfis de usuários no AdonisJs.
</blockquote>

<h3>Autenticadores</h3>
<p>
  Cada autenticador é uma combinação de esquema de autenticação e serializador.
</p>
<h4>Schemes</h4>
<ul>
  <li>Session (session)</li>
  <li>Basic Auth (basic)</li>
  <li>JWT (jwt)</li>
  <li>Personal API Tokens (api)</li>
</ul>

<h4>Serializers</h4>
<ul>
  <li>Lucid (lucid)</li>
  <li>Database (database)</li>
</ul>


<h3>Categorias de Autenticação</h3>
<p>
  A autenticação é dividida em duas grandes categorias: com estado - <i>stateful</i> e sem estado - <i>stateless</i>.
</p>
<p>
  A autenticação baseada em sessão é considerada com estado - <i>stateful</i> - desde que 
  os usuários conectados possam navegar para diferentes áreas do aplicativo sem reenviar suas credenciais.
</p>
<p>
  A autenticação sem estado - <i>stateless</i> - exige que o usuário reenvie suas credenciais em 
  cada solicitação HTTP, o que é muito comum nas APIs.
</p>
<p>
  AdonisJs fornece ferramentas e ajudantes necessários para gerenciar os dois 
  tipos de autenticação com facilidade.
</p>


<h3>Hashing de Senha</h3>
<p>
  O provedor de autenticação AdonisJs usa o módulo 
  <a href="https://adonisjs.com/docs/4.1/encryption-and-hashing#_hashing_values" target="_blank" rel="noopener noreferrer">Hash</a> para verificar as senhas.
</p>
<p>
  Sempre <a href="https://adonisjs.com/docs/4.1/database-hooks#_defining_hooks" target="_blank" rel="noopener noreferrer">faça o hash</a> de suas senhas antes de salvá-las no banco de dados.
</p>


<h3>Setup</h3>
<p>
  O provedor de autenticação do AdonisJs vem pré-instalado com os recursos de <code>fullstack</code> e <code>api</code>.
</p>
<p>
  Se o provedor de autenticação ainda não estiver configurado, siga as instruções abaixo.
</p>
<p>
  Primeiro, execute o comando adonis para baixar o provedor de autenticação:
</p>
<pre><code [highlight]="code"></code></pre>
<p>
  Em seguida, registre o provedor de autenticação dentro do arquivo <code>start/app.js</code>:
</p>
<pre><code [highlight]="code1"></code></pre>
<p>
  Finalmente, registre o middleware de autenticação dentro do arquivo <code>start/kernel.js</code>:
</p>
<pre><code [highlight]="code2"></code></pre>


<h3>Config</h3>
<p>
  Sua configuração de autenticação é salva dentro do arquivo <code>config/auth.js</code>.
</p>
<p>
  Por padrão, o autenticador <code>session</code> é usado para autenticar solicitações de aplicativos.
</p>


<h3>Exemplo básico</h3>
<p>
  Vamos começar com o exemplo de login em um usuário e, em seguida, 
  apenas mostrando o perfil dele se ele estiver conectado.
</p>
<p>
  Primeiro, adicione as seguintes rotas ao arquivo <code>start/routes.js</code>:
</p>
<pre><code [highlight]="code3"></code></pre>
<p>
  Em seguida, crie o UserController através do comando adonis:
</p>
<pre><code [highlight]="code4"></code></pre>
<p>
  Adicione o método de login ao UserController:
</p>
<pre><code [highlight]="code5"></code></pre>
<p>
  O método <code>login</code> acima extrai o <code>email</code> e a <code>password</code> do usuário da solicitação e 
  registra-os se suas credenciais forem válidas.
</p>
<p>
  Finalmente, adicione o método <code>show</code> ao <code>UserController</code>:
</p>
<pre><code [highlight]="code6"></code></pre>
<p>
  O método <code>show</code> acima verifica se o parâmetro <code>id</code> é igual ao ID do usuário atualmente logado. 
  Em caso afirmativo, o modelo de usuário autenticado é retornado (o que o AdonisJS converte em 
  JSON na resposta final).
</p>


<h3>Session</h3>
<h4>Session Config</h4>
<pre><code [highlight]="code7"></code></pre>
<br>
<table class="uk-table">
  <thead>
    <tr>
      <th>Chave</th>
      <th>Valores</th>
      <th>Descrição</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>serializer</td>
      <td>
        <code>lucid</code>, <code>database</code>
      </td>
      <td>Serializador usado para buscar o usuário do banco de dados.</td>
    </tr>
    <tr>
      <td>scheme</td>
      <td><code>session</code>, <code>basic</code>, <code>jwt</code>, <code>api</code></td>
      <td>Esquema usado para buscar e autenticar as credenciais do usuário.</td>
    </tr>
    <tr>
      <td>uid</td>
      <td>Nome do campo do banco de dados</td>
      <td>Campo do banco de dados usado como o identificador exclusivo de um determinado usuário.</td>
    </tr>
    <tr>
      <td>password</td>
      <td>Nome do campo do banco de dados</td>
      <td>Campo usado para verificar a senha do usuário.</td>
    </tr>
    <tr>
      <td>model</td>
      <td>Namespace do modelo (apenas <code>lucid</code>)</td>
      <td>Modelo usado para consultar o banco de dados, aplicável somente ao usar o serializador <code>lucid</code>.</td>
    </tr>
    <tr>
      <td>table</td>
      <td>Nome da tabela de banco de dados (somente <code>database</code>)</td>
      <td>Aplicável somente ao usar o serializador de <code>database</code>.</td>
    </tr>
  </tbody>
</table>


<h4>Métodos de Sessão</h4>
<p>
  O autenticador de sessão expõe os seguintes métodos para efetuar login e autenticar usuários.
</p>

<h5>attempt(uid, password)</h5>
<p>
  Login via <code>uid</code> e <code>password</code>, lançando uma exceção se nenhum usuário for encontrado ou a senha for inválida:
</p>
<pre><code [highlight]="code8"></code></pre>

<h5>login(user)</h5>
<p>
  Login por meio da instância do modelo <code>user</code>, não verifique nada, apenas marque o usuário como logado:
</p>
<pre><code [highlight]="code9"></code></pre>

<h5>loginViaId(id)</h5>
<p>
  Login via user id, consultando o banco de dados para garantir que o usuário existe:
</p>
<pre><code [highlight]="code10"></code></pre>

<h5>remember</h5>
<p>
  Ao chamar métodos como <code>attempt</code>, <code>login</code> ou <code>loginViaId</code>, 
  encadeie o método <code>remember</code> para garantir que os usuários permaneçam conectados 
  depois de fechar o navegador:
</p>
<pre><code [highlight]="code11"></code></pre>

<blockquote>
  O método <code>remember</code> cria um token para o usuário dentro da tabela de tokens. 
  Se você quiser revogar a sessão de longa duração de um usuário específico, 
  basta definir <code>is_revoked</code> como true.
</blockquote>

<h5>check</h5>
<p>
  Verifique se um usuário já está logado lendo sua sessão:
</p>
<pre><code [highlight]="code12"></code></pre>

<h5>getUser</h5>
<p>
  Retorna a instância do usuário logado (através do método <code>check</code>):
</p>
<pre><code [highlight]="code13"></code></pre>

<h5>logout</h5>
<p>
  Efetue logout do usuário conectado no momento:
</p>
<pre><code [highlight]="code14"></code></pre>


<h3>Autenticação básica</h3>
<p>
  Como a autenticação básica é stateless com usuários passando credenciais por 
  solicitação, não há nenhum conceito de login e logout.
</p>
<blockquote>
  O cabeçalho <code>Authorization = Basic credentials</code> deve ser configurado 
  para autenticar as solicitações de autenticação básicas, em que <code>credentials</code> 
  é uma string codificada em <code>base64</code> de <code>uid:password</code>, 
  em que <code>uid</code> é o campo do banco de dados <code>uid</code> definido 
  no arquivo <code>config/auth.js</code>.
</blockquote>

<h4>Métodos de Autenticação Básica</h4>
<p>
  O autenticador básico expõe os seguintes métodos para autenticar usuários.
</p>

<h5>check</h5>
<p>
  Verifique as credenciais básicas de autenticação do usuário no cabeçalho da 
  solicitação, confirmando a existência do usuário e validando a senha:
</p>
<pre><code [highlight]="code15"></code></pre>

<h5>getUser</h5>
<p>Retorna a instância do usuário logado (através do método <code>check</code> ):</p>
<pre><code [highlight]="code16"></code></pre>


<h3>JWT</h3>
<p>
  A autenticação <a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">JWT</a> 
  é um padrão da indústria para implementar autenticação sem estado por meio de tokens de string.
</p>
<p>
  AdonisJs suporta tokens JWT fora da caixa através do seu autenticador jwt.
</p>
<blockquote>
  O cabeçalho <code>Authorization = Bearer &lt;token&gt;</code> deve ser configurado 
  para autenticar solicitações jwt, em que o <code>&lt;token&gt;</code> é um token JWT válido.
</blockquote>

<h4>JWT Config</h4>
<p>
  Arquivo de configuração para JWT, em <code>config/auth.js</code>:
</p>
<pre><code [highlight]="code17"></code></pre>
<table class="uk-table">
  <thead>
    <tr>
      <th>Chave</th>
      <th>Valores</th>
      <th>Valor padrão</th>
      <th>Descrição</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>algorithm</td>
      <td><code>HS256</code>, <code>HS384</code></td>
      <td><code>HS256</code></td>
      <td>Algoritmo usado para gerar tokens</td>
    </tr>
    <tr>
      <td>expiresIn</td>
      <td>Tempo válido em segundos ou <a href="https://github.com/rauchg/ms.js" target="_blank" rel="noopener noreferrer">ms string</a></td>
      <td>null</td>
      <td>Quando expira o token</td>
    </tr>
    <tr>
      <td>notBefore</td>
      <td>Tempo válido em segundos ou <a href="https://github.com/rauchg/ms.js" target="_blank" rel="noopener noreferrer">ms string</a></td>
      <td>null</td>
      <td>Tempo mínimo para manter os tokens válidos</td>
    </tr>
    <tr>
      <td>audience</td>
      <td>String</td>
      <td>null</td>
      <td>Requerer <code>aud</code></td>
    </tr>
    <tr>
      <td>issuer</td>
      <td>Array ou String</td>
      <td>null</td>
      <td>Requerer <code>iss</code></td>
    </tr>
    <tr>
      <td>subject</td>
      <td>String</td>
      <td>null</td>
      <td>Requerer <code>sub</code></td>
    </tr>
  </tbody>
</table>

<h4>Métodos JWT</h4>
<p>
  O autenticador jwt expõe os métodos a seguir para gerar tokens JWT e autenticar usuários.
</p>

<h5>attempt(uid, password, [jwtPayload], [jwtOptions])</h5>
<p>
  Valida as credenciais do usuário e gera um token JWT em troca:
</p>
<pre><code [highlight]="code18"></code></pre>
<p>
  Saída:
</p>
<pre><code [highlight]="code19"></code></pre>

<h5>generate(user, [jwtPayload], [jwtOptions])</h5>
<p>
  Gere o token JWT para um determinado usuário:
</p>
<pre><code [highlight]="code20"></code></pre>
<p>
  Como opção, você pode passar um objeto personalizado para ser codificado no token. 
  Passar <code>jwtPayload = true</code> codifica o objeto do usuário dentro do token.
</p>

<h5>withRefreshToken</h5>
<p>
  Instrua o autenticador do JWT a gerar um token de atualização também:
</p>
<pre><code [highlight]="code21"></code></pre>
<p>
  O token de atualização é gerado para que os clientes possam atualizar o 
  token jwt real sem solicitar as credenciais do usuário novamente.
</p>

<h5>generateForRefreshToken(refresh_token, [jwtPayload])</h5>
<p>
  Gere um novo token JWT usando o token de atualização. Usar a opção <code>jwtPayload = true</code> 
  codifica o objeto do usuário dentro do token.
</p>
<pre><code [highlight]="code22"></code></pre>

<h5>newRefreshToken</h5>
<p>
  Ao gerar um novo token jwt, o provedor de autenticação não emitirá um novo token de 
  atualização, em vez disso, usará o antigo. Se desejar, você também pode gerar um novo token de atualização:
</p>
<pre><code [highlight]="code23"></code></pre>

<h5>check</h5>
<p>
  Verifica se um token JWT válido foi enviado por meio do cabeçalho <code>Authorization</code>:
</p>
<pre><code [highlight]="code24"></code></pre>

<h5>getUser</h5>
<p>
  Retorna a instância do usuário logado (através do método <code>check</code>):
</p>
<pre><code [highlight]="code25"></code></pre>

<h5>listTokens</h5>
<p>
  Lista todos os tokens de atualização do JWT para o usuário:
</p>
<pre><code [highlight]="code26"></code></pre>


<h3>Personal API tokens</h3>
<p>
  Os tokens de API pessoal foram tornados 
  populares pelo <a href="https://github.com/blog/1509-personal-api-tokens" target="_blank" rel="noopener noreferrer">Github</a> para uso em 
  scripts como um substituto revogável da autenticação tradicional de e-mail e senha.
</p>
<p>
  O AdonisJs permite que você crie aplicativos onde seus usuários podem 
  criar tokens de API pessoais e usá-los para autenticar
</p>
<blockquote>
  O cabeçalho <code>Authorization = Bearer &lt;token&gt;</code> deve ser 
  configurado para autenticar solicitações de autenticação de API, em que &lt;token&gt; é um token de API válido.
</blockquote>

<h4>Métodos de API</h4>
<p>
  O autenticador da API expõe os métodos a seguir para gerar tokens de API e autenticar usuários.
</p>

<h5>attempt(uid, password)</h5>
<p>
  Valide as credenciais do usuário e gere um novo token para elas:
</p>
<pre><code [highlight]="code27"></code></pre>
<pre><code [highlight]="code28"></code></pre>

<h5>generate(user)</h5>
<p>
  Gerar token para um determinado usuário:
</p>
<pre><code [highlight]="code29"></code></pre>

<h5>check</h5>
<p>
  Verifica se um token de API válido foi passado pelo cabeçalho de <code>Authorization</code>:
</p>
<pre><code [highlight]="code30"></code></pre>

<h5>getUser</h5>
<p>
  Retorna a instância do usuário logado (através do método <code>check</code>):
</p>
<pre><code [highlight]="code31"></code></pre>

<h5>listTokens</h5>
<p>
  Listar todos os tokens da API para o usuário:
</p>
<pre><code [highlight]="code32"></code></pre>


<h3>Autenticadores de comutação</h3>
<p>
  O provedor de autenticação simplifica a alternância entre vários autenticadores 
  em tempo de execução, chamando o método <code>authenticator</code>.
</p>
<p>
  Supondo que o usuário esteja logado usando o autenticador de <code>session</code>, 
  podemos gerar um token JWT para eles da seguinte forma:
</p>
<pre><code [highlight]="code33"></code></pre>

<h3>Middleware de Autenticação</h3>
<p>
  O middleware de autenticação automatiza a autenticação para quaisquer rotas aplicadas.
</p>
<p>
  Está registrado como um middleware nomeado dentro do arquivo <code>start/kernel.js</code>:
</p>
<pre><code [highlight]="code34"></code></pre>
<p>
  Uso:
</p>
<pre><code [highlight]="code35"></code></pre>


<h3>Middleware Convidado</h3>
<p>
  O middleware <code>guest</code> verifica se o usuário não está autenticado.
</p>
<p>
  Está registrado como um middleware nomeado dentro do arquivo <code>start/kernel.js</code>:
</p>
<pre><code [highlight]="code36"></code></pre>
<p>
  Uso:
</p>
<pre><code [highlight]="code37"></code></pre>


<h3>Helpers</h3>
<p>
  O provedor de autenticação adiciona alguns auxiliares à instância da exibição 
  para que você possa gravar o HTML em torno do estado de um usuário que efetuou login.
</p>

<h5>auth</h5>
<p>
  Referência ao objeto auth:
</p>
<pre><code [highlight]="code38"></code></pre>

<h5>loggedIn</h5>
<p>
  A tag de <code>loggedIn</code> pode ser usada para escrever <code>if/else</code> em torno do usuário conectado:
</p>
<pre><code [highlight]="code39"></code></pre>


<h3>Revogando Tokens</h3>
<p>
  Os esquemas <code>jwt</code> e <code>api</code> expõem métodos para revogar os 
  tokens usando a interface <code>auth</code>.
</p>
<blockquote>
  Para o <code>jwt</code>, a atualização de tokens são revogados apenas, 
  pois os tokens reais nunca são salvos no banco de dados.
</blockquote>

<h4>revokeTokens(tokens, delete = false)</h4>
<p>
  O método a seguir revogará os tokens definindo um sinalizador na tabela de tokens:
</p>
<pre><code [highlight]="code40"></code></pre>
<p>
  Se <code>true</code> for passado como o segundo argumento, em vez de definir o 
  sinalizador de banco de dados <code>is_revoked</code>, a linha relevante será excluída do banco de dados:
</p>
<pre><code [highlight]="code41"></code></pre>
<p>
  Para revogar todos os tokens, chame <code>revokeTokens</code> sem nenhum argumento:
</p>
<pre><code [highlight]="code42"></code></pre>
<p>
  Ao revogar o token da API para o usuário atualmente conectado, 
  você pode acessar o valor no cabeçalho da solicitação:
</p>
<pre><code [highlight]="code43"></code></pre>

<h4>revokeTokensForUser(user, tokens, delete = false)</h4>
<p>
  Este método funciona da mesma forma que o método revokeTokens, mas você pode especificar o usuário:
</p>
<pre><code [highlight]="code44"></code></pre>


<h3>Criptografia de Token</h3>
<p>
  Os tokens são salvos em formato simples dentro do banco de dados, 
  mas são enviados em formato criptografado para o usuário final.
</p>
<p>
  Isso é feito para garantir que, caso alguém acesse seu banco de dados, 
  ele não poderá usar seus tokens diretamente (eles teriam que descobrir 
  como criptografá-los usando a chave secreta).
</p>